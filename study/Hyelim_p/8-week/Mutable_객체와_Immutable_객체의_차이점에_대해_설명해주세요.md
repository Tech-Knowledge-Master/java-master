# Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.

## 불변객체
* 객체 생성 이후에는 객체의 상태가 바뀌지 않는 객체
* String, Boolean, Integer, Float, Long  - String 을 제외하고 원시타입의 wrapper 타입
> 스트링의 경우 값을 변경하면 실제 객체의 값이 변경된 것이 아니라, 새로운 객체를 새로 생성하고 이 객체에 대한 참조값을 변경한 것이다.

### 불변 객체 사용 이유
" 클래스들은 가변적이어야하는 매우 타당한 이유가 있지 않는 한, 반드시 불변으로 만들어야한다. 클래스를 불변으로 만드는 것이 불가능하다면, 가능한 변경 가능성을 최소화 해라"

* 단순하다
* 스레드 안정성 보장
* 값의 변경 방지
* 불변 객체는 객체의 필드로 사용
* String - immutable 객체, StringBuilder - mutable 객체, StringBuffer- mutable 객체

## 깊은 복사 vs 얕은 복사


### 얕은 복사
* 원본 객체를 복사할 때, 새로운 객체를 만들지만 원본 객체의 주소 값을 참조하는 복사
* 복사한 배열 수정시 원래 배열 수정됨.
* 단순 배열 변수 선언을 통한 복사 방법이 이에 해당됨. (int[] B = A;)
* call-by-reference와 유사한 개념

### 깊은 복사
* 원본 객체를 복사할 때, 새로운 객체를 만들고, 원본 객체의 모든 값을 복사해서(모든 내부 상태를 완전히 복사) 원본 객체로부터 독립적인 객체를 생성한다.
* 배열 A를 그대로 가져와 새로운 배열을 만듬.
* 복사한 배열(새로운 배열 B)를 수정해도 배열 A는 영향받지 않음.
* A.clone() 을 사용하여 깊은 복사할 수 있음. - 1차원 배열만 가능
* call-by-values 와 유사한 개념
> String 은 복사 시 얕은 복사를 하더라도 깊은 복사처럼 작동함

### 방어적 복사
* 내부의 객체를 반환할 때, 객체의 복사본을 만들어서 반환하는 것
* 방어적 복사를 하게 되면, 복사한 외부의 객체를 변경해도 원본 내부 객체가 변경되지 않는다.
* 방어적 복사는 깊은 복사가 아니다 - 깊은 복사라면, 원본과 복사본을 비교해봤을 때 모든 요소의 참조 값이 달라야하지만 그렇지 않다.
* 복사본이 원본의 주소를 그대로 참조하여 사용하지는 않지만, 복사본 객체 내부에 있는 객체들은 원본과 동일한 주소를 참조하게 된다.
* 객체 내부 필드의 값을 외부로부터 보호하는 것이 목적
### 복사하여 반환 시 사용할 5가지 방법
1. getter 그대로 collection 반환 
   * 방어적 복사 x, 얕은 복사
2. new ArrayList<>() 로 새로운 List 생성해서 반환 
   * 방어적 복사, 얕은 복사 
   * 리스트 안에 객체 요소가 변경되면 서로에게 영향 끼침
3. Collections.unmodifiableList() 로 Collection 반환 
   - 방어적 복사 x, 얕은 복사 
   - 복사한 리스트를 변경 불가능하게 만든다. 
   - 복사한 리스트 자체에 접근을 시도하면 UnsupportedOperationException 이 발생
   - 복사한 리스트의 수정을 막는 것이고 방어적 복사가 아니기에 원본 리스트를 변경시 복사한 리스트도 변경된다.
4. List.copyOf() 로 Collection 반환 
   - 방어적 복사, 얕은 복사 
   - 내부에서 반환된 리스트를 변경하면 안된다.
5. 복사 생성자 + toUnmodifiableList()  
   - 방어적 복사, 깊은 복사
   - 유일하게 '리스트 안의 객체 요소 변경'에 대해 해결할 수 있다
> 리스트 안의 객체가 불변 객체라면 스트림 반복 비용등을 고려해 4번 방식을 채택하는게 좋다.


> ### 상황별 비교
> 1. 내부에서 반환한 리스트를 변경해도 된다(해야한다).
>  - new ArrayList<>() 사용
> 2. 내부에서 반환한 리스트를 변경하면 안 되고, 원본 리스트가 변경될 일이 없다.(변경될 때 복사한 리스트에 영향을 줘도 된다.)
>  - Collections.unmodifiableList() 사용
> 3. 내부에서 반환한 리스트를 변경하면 안되고, 원본 리스트 변경 시 복사한 리스트에 영향을 주면 안된다.
> - List.copyOf() 사용
> 4. 내부에서 반환한 리스트 안의 객체 요소까지 내부 원본 객체에 영향을 주지 않아야한다.
> - 복사 생성자 + unmodifiableList() 사용

---
https://injae7034.github.io/java/ninth/ <br/>
https://ksh-coding.tistory.com/77 <br/>
https://hello-judy-world.tistory.com/209 <br/>
https://injae7034.github.io/java/ninth/

