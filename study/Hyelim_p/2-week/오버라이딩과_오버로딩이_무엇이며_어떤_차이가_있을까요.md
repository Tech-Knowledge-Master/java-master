# 오버라이딩과 오버로딩의 차이점
자바의 다형성을 지원하는 방법으로 오버라이딩과 오버로딩이 있다. 
### 메소드 오버라이딩
부모 클래스에서 상속받은 메서드와 동일한 이름의 메서드를 재정의하는 것으로, 컴파일 타임이 아닌 런타임에
실제 인스턴스의 가상 메서드 테이블을 보고 결정되기에 런타임 다형성이라고도 불린다.
### 메소드 오버로딩
이름은 동일하지만 메소드 시그니처가 다른 여러개의 메서드를 같은 공간에 정의하는 것
> 메소드 시그니처: 메서드의 이름과 매개변수 리스트의 조합

### 메소드 오버라이딩의 조건
1. 부모 클래스의 메소드와 시그니처 및 리턴 타입이 동일해야한다.
2. 부모 클래스의 메소드 보다 접근 지정자의 범위가 같거나 넓어야한다.
    * 하위 클래스의 접근 지정자가 더 좁으면 하위 클래스의 메소드에 더 많은 제한을 거는 것으로 다형성의 개념과 멀어진다.
    * 다형성은 상위 클래스 타입의 참조변수가 하위 클래스의 인스턴스를 가리킬 수 있게 하는 것인데, 접근 제어자의 범위가 좁아지면
   상위 클래스의 타입의 참조변수로 해당 메소드를 접근할 수 없다.

      

### 다운 캐스팅

참조 변수의 타입에 따라 접근 멤버가 결정된다.
```P p=new C()``` 로 선언된 코드에서 참조변수가 p이기 때문에 C 클래스에만 선언된 변수와 메서드는 접근이 불가능하다.
이럴 경우 다운 캐스팅을 통해 자식 클래스의 메서드에 접근할 수 있다.

### 오버라이딩과 가상 메소드 테이블
자식 클래스에서 오버라이딩한 메서드는 가상 메서드 테이블을 이용해서 접근이 가능하다.
가상 메서드 테이블은 객체의 가상 메서드에 대한 포인터들을 담고 있는 테이블인데, 이 테이블은
클래스 당 하나가 생성되며 각 클래스의 인스턴스가 이 테이블에 대한 포인터를 지닌다.

따라서 자식 클래스로 생성된 부모 타입의 참조변수가 오버라이딩 된 메서드를 호출 시 실체 객체 타입을 확인하고 해당 클래스의
가상 메서드 테이블을 참조하여 오버라이딩된 메서드를 호출한다.

정리하자면, 
오버라이딩된 메서드 호출 시 JVM은 스택 영역의 참조 변수를 통해 힙 영역의 실제 객체를 찾고,
그 객체의 VMT를 통해 실제 메서드의 주소를 찾아내어 실행한다. 

이렇게 함으로써 동적 디스패치(Dynamic Dispatch)가 이루어져 오버라이딩된 메서드가 호출한다

> 메서드 호출 -> 메서드의 명령 집합이 있는 메모리 위치 참조해 명령을 실행하는 것, 가상 메서드의 경우 가상 메서드 테이블이 생성된다.
> 가상 메서드 테이블은 각 메서드 이름과 실제 메모리 주소가 짝을 이룬다. 어떤 메서드가 호출되면 이 테이블에서 주소 값을 찾아 메서드 명령을 수행한다.
> 자식 클래스를 생성하면 부모 클래스에서 재정의 되지 않은 메서드의 경우 가상 메서드 테이블의 메서드 주소는 부모랑 동일 하다, 나머지는 자식에서 새로 정의된다.
### super()
자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.
한편 모든 객체는 클래스의 생성자를 호출해야만 생성되기에 자식 객체를 생성하려면 부모 생성자를 호출해야한다.
(부모 클래스에 기본 생성자만 있다면 컴파일러가 암묵적으로 기본 생성자를 추가해준다.)

> 생성자는 클래스에 최소 1개는 있어야 하며, 생성자 코드가 없을 경우 컴파일러가 기본생성자를 자동으로 생성한다. 단 생성자 코드가 
1개라도 작성되어 있다면, 컴파일러는 기본생성자가 없다고 하더라도 기본생성자를 자동으로 생성하지 않는다.
```java
//BusinessException 는 매개변수가 있는 생성자만 존재
@Getter
public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;

    public BusinessException(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }
}
```
```java
//BusinessException을 상속받아 기본생성자와 매개변수 있는 생성자 생성, 기본 생성자의 경우 super 를 사용해 명시적으로 부모 클래스의 생성자 지정(없으면 에러남)
public class UnauthorizedException extends BusinessException {
    public UnauthorizedException() {
        super(ErrorCode.UNAUTHORIZED);
    }

    public UnauthorizedException(ErrorCode errorCode) {
        super(errorCode);
    }
}
```
