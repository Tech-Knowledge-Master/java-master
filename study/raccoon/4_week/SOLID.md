# ✎ SOLID
로버트 마틴이 2000년대 초반 명명한 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 두문자어 기억술로 소개한 것

| 두문자 | 약어  | 개념                                            |
|-----|-----|-----------------------------------------------|
| S   | SRP | 단일 책임 원칙 (Single Responsibility Principle)    |
| O   | OCP | 개방 - 폐쇄 원칙 (Open / Closed Principle)          |
| L   | LSP | 리스코프 치환 원칙 (Liskov Substitution Principle)    |
| I   | ISP | 인터페이스 분리 법칙 (Interface Segregation Principle) |
| D   | DIP | 의존관계 역전 원칙 (Dependency Inversion Principle)   |

## 단일 책임 원칙(SRP)
여기서 SRP는 하나의 모듈이 하나의 책임을 가진다는 모호한 원칙이 아니라 '**모듈이 변경되는 이유가 한가지 이다**'라고 받아드려야 한다.

여기서 변경의 이유가 한가지라는 뜻은 '**해당 모듈이 여러 대상 또는 액터들에 대해 책임을 가져서는 안되고, 오직 하나의 액터에 대해서만 책임을 가져야 한다**'이다.

즉, 이 모듈을 수정하는 이유가 한가지가 아니라면(ex, 기존 회원가입 로직에서 암호화하는 코드와 유저를 저장하는 코드가 같은 메서드에서 구현되어 있다면, 암호화 변경 요구와 유저 저장 정보 추가같은 다른 이유로 인한 변경 요청이 존재) 메서드를 구분해서 작성해야 한다는 원칙이다.

이렇게 코드를 구현했을 경우, 요청에 대한 수정이 **단 한번**만 필요하게 된다는 것이다. 프로젝트가 커지면 커질수록 이런 방향성은 더욱 힘을 받는다.

하지만 무작정 모든 방향성에서 SRP를 판단하는 것이 아니라, 나중에 '이런 요구사항이 존재할 것인가?'에 대한 고민을 먼저 하고 있다면 구분하여 작성하는 방식을 추천한다.

## 개방 - 폐쇄 원칙 (OCP)
확장에는 열려있고, 수정에 대해서는 닫혀있어야 한다는 원칙을 말한다.
- **확장에 대해 열려 있다**: 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다. 
- **수정에 대해 닫혀 있다**: 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.

단순하게 이해하면 수정할 때, 수정해야 하는 기능이 존재하는 클래스를 제외한 다른 클래스에서 수정이 일어나면 안된다는 이야기이다.

그럼 이렇게 설계할려면 객체가 서로 추상화에 의존해야 한다.

따라서 OCP가 본질적으로 이야기하는 내용은 추상화이며, 런타임 의존성과 컴파일타임 의존성에 대한 이야기로 귀결된다.

## 리스코프 치환 법칙(LSP)
하위 타입은 상위 타입을 대체할 수 있어야 한다는 것을 말한다.

해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변견되어도, 차이점을 인식하지 못한 채 상위 타입의 public interface를 통해 sub class를 사용할 수 있어야 한다.

즉, 하위 클래스는 상위 클래스의 동작 규칙을 따라야 한다.

자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.

## 인터페이스 분리 법칙(ISP)
클라이언트의 목적과 용도에 적합한 인터페이스만 제공하는 것을 말한다.

인터페이스 분리 법칙을 준수함으로써 모든 클라이언트가 자신의 관심에 맞는 public interface만을 접근하여 불필요한 간섭을 최소화해야 한다.

즉 상속받거나 인터페이스를 받을 때, 클라이언트가 사용하지 않는 메서드에 접근하게 된다면 불필요한 결합성이 증가하고 이런 현상은 코드 수정에 악영향을 끼치게 된다.

따라서 만약 불필요한 접근이 생기게 된다면 아예 새로 인터페이스를 만들어 접근하도록 하는 것을 권장하는 방식이 ISP이다.

## 의존 관계 역전 법칙(DIP)
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며, 저수준 모듈이 고수준 모듈에 의존해야 한다는 것을 말한다.

- 고수준 모듈 : 입력과 출력으로부터 먼(비지니스와 관련된) 추상화된 모듈
- 저수준 모듈 : 입력과 출력으로부터 가까운(HTTP, DB, Cash 등과 관련된) 구현 모듈
 
✹ 비지니스와 관련된 부분이 세부 사항에는 의존하지 않는 설계 원칙

즉 클라이언트는 구현체에 결합성이 있으면 안되고, 추상체에 의존해야 한다는 말이다.


### 참고 자료
- https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)
- https://mangkyu.tistory.com/194
- 