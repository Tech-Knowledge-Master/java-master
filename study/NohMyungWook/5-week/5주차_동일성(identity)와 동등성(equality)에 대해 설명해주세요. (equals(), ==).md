## 동일성(identity)와 동등성(equality)

### 한줄답변
> 동일성과 동등성의 차이는 무엇인가요?
> > 두 객체가 할당된 메모리 주소가 일치하면 동일하고, 두 객체가 저장하고 있는 정보가 같으면 동등합니다.
> 
> == 연산자와 equals()의 차이는 무엇인가요?
> > == 연산자는 동일성을 판단하는데 사용되고, equals()는 동등성을 판단하는데 사용됩니다.
> 

### 동일성(identity) 란?
> 특정 개체끼리의 비교에서 동일한지에 대한 여부를 나타낸다.
> 즉, 완전히 같은 경우를 의미하며 주소 값이 같다. 
> 
> 그러나, 원시타입의 경우는, 객체가 아니므로 주소가 없다. 따라서 내용이 같으면
> 동일하다고 취급된다.

동일성을 확인하는 연산자는 <strong>==</strong>이다.

### 동등성(equality) 이란?
> 특정 개체끼리의 비교에서 객체가 같은 정보를 담고 있는지에 대한 여부를 나타낸다.
> 주소값이 다르더라고, 내용이 같으면 동등한다고 취급한다.

동등성을 확인하기 위해 사용하는 연산자는 <strong>equals()</strong> 함수다.

### 예시
```java
String str1 = new String("abc");
String str2 = new String("abc");

System.out.println(str1 == str2);
System.out.println(str1.equals(str2));
```

### 주의점
동등성을 확인하기 위해 equals()를 사용하지만, 모든 객체에 대해서 동등성을 판단할 수 있는 것은 아니다.
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
return 부를 보면 <strong>==</strong> 연산자를 통해 단순 동일성 비교를 한다는 것을 알 수 있다.
따라서 자식객체에서 equals()는 재정의 되어야지만 동등성 비교가 가능하다.

💡 대표적으로, String 클래스에서는 equals()를 각 문자 하나하나가 같은지 비교해서
전부 같을 경우 동등하다고 판단되게끔 재정의되어있다.

> 즉, 개발자가 커스텀 객체를 생성하였으면 반드시 equals()에 대한 재정의가 필요하다.
 
#### 왜 equals()를 재정의 할 때 hashCode()도 함께 override 해야할까?
List, Map, Set 등의 Collection 사용에서는 어떤 데이터가 존재하는지 확인하기 위해서는
해싱 알고리즘을 사용합니다.

해싱 알고리즘을 사용할 때 필요한 것이 hashCode()입니다.
Object 클래스의 hashCode는 native 메소드이고, 메모리 주소값을 정수로 변환한 값을 반환합니다.
인스턴스를 생성할 때 hashCode메소드도 오버라이드 하지 않을 경우 다른 주소값을 리턴하기 때문에 동등성을 보장할 수 없습니다.

즉, 특정 필드값과 같이 조건을 걸어 hashCode가 동일하도록 설정하면 이는 동등성을 보장할 수 있습니다.