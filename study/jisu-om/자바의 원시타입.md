# 원시타입

### 원시타입의 종류
- 논리형
	- boolean : 1byte


- 문자형
	- char : 2byte  
	  Java에서 유일하게 제공되는 unsigned 형태 (음수 없이 0부터 시작하여 양수 값만 가지는 데이터 형태)  


- 정수형
JVM은 연산할 때 피연산자 스택을 활용한다. 이때 피연산자 스택은 피연산자를 4 bytes 단위로 저장한다. 즉, char, short 같이 int 보다 작은 자료형의 값을 계산하면 int형으로 자동 형변환되어 연산이 수행된다. 
	- byte : 1byte (-2⁷ ~ 2⁷-1)
	- short : 2byte (-2¹⁵ ~ 2¹⁵-1)
	- int : 4byte (-2³¹ ~ 2³¹-1)
	  정수형 데이터 타입의 디폴트 
	- long : 8byte (-2⁶³ ~ 2⁶³-1)


- 실수형 
	- double : 4byte
	  실수형 데이터 타입의 디폴트 
	- float : 8byte


### 참조타입
힙 영역에 저장되며, 해당 객체들의 주소를 스택 영역에 저장한다.
기본형 이외 대부분의 타입들을 말하며, 배열, 클래스, 인터페이스 등이 있다. 


### Wrapper class 
- `==`연산을 할 수 없다.
  primitive type은 값을 비교하지만, wrapper class는 참조된 주소를 비교하여 같은 객체인지 확인 
- 불변 객체 
  새로운 객체를 생성하는 것이기 때문에 wrapper class는 불변 객체이다. 



### String 
- String은 바로 값을 대입하지만 원시타입이 아니다. 
- Java에서 리터럴 표현식(literal expression)을 사용할 수 있도록 특별대우 해주는 자료형
- Java heap memory에는 String pool 이라는 영역이 있다. 
  리터럴 표현식으로 String을 선언하게 되면 (`String s1 = "abc";`)
  String 내부에서 intern() 메서드를 호출하고 
  intern() 메서드는 heap 내에 있는 String pool 에서 해당 값이 있는지 먼저 확인한다.
  있다면 해당 주소값을 리턴하고, 없다면 pool 에 새로 생성하여 주소값을 리턴한다. 
- String이 리터럴 표현식으로 생성된다면 String pool 덕분에 wrapper class 이지만 `==`연산 수행 가능 
  String이 `new` 연산자로 생성된다면 `==`가 아니라 `equals`로 값을 비교해야 한다.
  (`String s2 = new String("abc");`)


### 원시타입의 특징
- null을 담을 수 없음
- 제네릭 타입에서 사용 불가
- 필요로 하는 메모리 양이 적음
- 참조타입에 비해 접근 속도 빠름 
  원시타입은 값이 스택 영역에 저장되고, 
  참조타입은 객체이기에 스택 영역에는 참조값(힙 메모리의 주소값)만 있고 실제 값은 힙 영역에 존재한다. 따라서 값을 필요로 할 때마다 최소 2번 메모리 접근을 해야하고, 일부 타입의 경우 필요 시 언박싱 과정(ex. Double -> double, Integer -> int) 을 거쳐야 해서 접근 속도가 느린 편이다. 
- cf) Java 1.5 ~ auto boxing/unboxing 지원 