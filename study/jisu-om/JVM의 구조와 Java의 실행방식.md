# JVM 이란?
- 바이트코드를 기계어로 변환하여 Java를 실행할 수 있게 하는 스택 기반 가상 컴퓨터 
- 레지스터 기반이 아닌 스택 기반 VM 을 사용한 이유
  : 다양한 하드웨어에서 VM을 쉽게 구현하여 플랫폼에 독립적
- WORA (Write once, run anywhere)
- OS 에 종속적이지 않음, 이식성이 높음
- Java로 작성된 소스코드가 직접 운영체제로 가서 실행되는 것이 아니라 JVM을 거쳐서 운영체제와 상호작용
- 단점) 두번의 컴파일 ; 실행속도 상대적으로 느림
  이를 보완하기 위해 JIT 컴파일러 사용


# JVM의 구조 
- Class Loader  
    - JVM 내에 클래스 파일을 로드하고, 링크를 통해 메모리에 배치하는 작업을 수행  
    - 바이트코드를 읽고 메모리에 적절하게 배치  
    - 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크한다.

- Execution Engine
  - 클래스 로더에 의해 메모리에 로드된 바이트코드를 실행하는 역할
  - 인터프리터  
    바이트코드를 한줄씩 읽어서 기계가 이해할 수 있는 언어로 변환  
  - JIT 컴파일러 (Just-in-time)
    - 인터프리터의 효율을 높이기 위한 컴파일러
    - 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔준다. 
      그 다음에 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다. 
    - JIT 컴파일러가 컴파일하는 과정은 바이트코드를 인터프리팅 하는 것보다 훨씬 오래 걸림
        -> 한번만 실행하는 코드라면 인터프리팅 하는 것이 유리 (JVM이 해당 메서드의 실행 빈도를 체크하여 자체 판단)
  - GC (Garbage Collector) : 힙 영역에서 사용(참조)되지 않는 객체들을 제거

- Runtime Data Area
    - 프로그램 수행을 위해 OS에서 할당받은 메모리 공간
    - Method area (메서드 영역)
    - Stack area
    - PC register (Program Counter)
    - Heap area
    - Native Method Stack
  
    - stack, pc register, native method stack은 쓰레드가 생성되면서 생성되고 각각의 쓰레드 단위로 수행됨
    - 

- JNI (Java Native Interface)
    - 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공
    - native 키워드를 사용해 메서드를 호출
    - (ex) Thread의 currentThread()

- Native Method Library
    - C, C++로 작성된 라이브러리
    - 자바 이외의 언어로 작성된 네이티브 메서드를 실행할 때 사용되는 메모리 영역
    - 일반적인 C스택 사용 


# Java 프로그램의 실행방식
1. 자바로 개발된 프로그램을 실행하면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.
2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트코드(.class 클래스파일)로 컴파일한다.
3. Class Loader를 통해 클래스파일들을 JVM으로 로딩한다. 
4. 로딩된 클래스 파일들은 실행엔진을 통해 해석된다. 
5. 해석된 바이트코드는 runtime data area 에 배치되어 수행된다.  
   이 과정에서 실행엔진에 의해 GC 작동과 쓰레드의 동기화가 이루어진다.

- `javac xxx.java` : 컴파일을 진행하면 해당 위치에 .class 파일이 생성된다.
- `java xxx`: JVM 실행 