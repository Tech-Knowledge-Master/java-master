# 제네릭
- JDK 1.5 도입
- 클래스 내부에서 사용할 데이터 타입을 클래스 내부가 아닌 외부에서 지정하는 기법


- 장점
  - 타입 안정성  
    제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 타임에 체크 가능
  - 타입 유연성  
    클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다.   
  - 코드의 재사용성이 높아진다.


- 타입 파라미터 컨벤션
  - T : Type (reference type 만 가능)  
  - E : Element
  - K : Key
  - N : Number 
  - V : Value
  - R : Result 
  - S, U, V, ... : 2번째, 3번째, 4번째 타입  


- 클래스, 인터페이스, 메서드에 선언 가능
- 제네릭 메서드
  - 제네릭 메서드를 정의할 때에는 리턴 타입이 무엇인지와 상관없이 내가 제네릭 메서드임을 컴파일러에게 알려줘야 함
  - 그래서 리턴 타입 정의하기 전에 제네릭 타입에 대한 정의를 반드시 명시! 
  - 제네릭 클래스가 아닌 일반 클래스에서도 제네릭 메서드 사용 가능
  - 즉, 클래스에 지정된 타입 파라미터와 제네릭 메서드에 정의된 타입 파라미터는 상관이 없음
  ```
  public class Car<T> {
      private final T name;
      
      private Car(T name) {
          this.name = name;
      }
  
      public static <M> Car<M> from(M name) {
          return new Car<>(name);
      }
  
      //generic method
      public <T> void printEqualsCar(Car<T> car) {
          System.out.println(this.equals(car));
      }
  }
  ```

- 불공변 -> PECS(Producer Extends Consumer Super)  
  - 해당 파라미터 입장에서 
  - 해당 파라미터가 producer 이면 (ex. source 역할) extends 사용 (최대치)
  - consumer 이면 (ex. target, destination 역할) super 사용 (최소치)
  - GEPS (Get Extends Put Super)
  ```
  public static <T> void copy(List<? extends T> source, List<? super T> target) {
      for (T element : source) {
          target.add(element);
      }
  }
  ```


- 제한된 제네릭, 와일드카드 
  - `<K extends T>` : T와 T의 자손만 가능, 특정 타입으로 지정됨
  - `<K super T>` : T와 T의 조상만 가능
  - 아래 두개 (와일드카드를 사용한 제네릭) 는 리턴타입으로는 사용 X 
  - 와일드카드 사용하는 이유 : 제네릭에 유연성을 추가하기 위해서 (공변을 추가)
  - `<? extends T>`  
  - `<? super T>` 
  - `<?>` : = `<? extends Object>`  
    와일드카드, 알 수 없는 타입, 모른다. 어떤 타입이든 상관없다.


- Type Erasure
  - 제네릭은 JDK 1.5 버전에 도입되었기에 하위 버전과의 호환성을 위한 작업
  - 컴파일 시점에 타입 체크를 한 후, 런타임에는 타입 관련 정보를 지움 (바이트 코드 레벨에서 제거됨)
    - 런타임 시 타입 체크 어렵다는 한계 가짐  
      - 방법
        - 제네릭 타입을 사용할 수 있는 일반 클래스, 인터페이스, 메서드에만 소거 규칙을 적용한다. 
        - unbounded type(`<?>`, `<T>`) 은 `Object` 로 변환
        - bound type 의 경우 : ex. `<E extends Comparable<E>` -> `Comparable`로 변환
        - 타입 안정성 보존을 위해 필요하다면 type casting 을 넣는다.
        - 확장된 제네릭 타입에서 다형성을 보존하기 위해 bridge method 를 생성한다. 
        ```
        //컴파일 전
        public class Test<T extends Comparable<T>> { 
            private T data;
          
            public T getData() {
                return data;
            }
       
           public void setData(T data) {
                this.data = data;
           }
        }
   
        //컴파일 후 
        public class Test {
            private Comparable data;
       
            public Comparable getData() {
                return data;
            }
       
            public void setData(Comparable data) {
                this.data = data;
            }
        }
        ```
        ```
        //컴파일 전
        public class MyComparator implements Comparator<Integer> {
            public int compare(Integer a, Integer b) {
                //...
            }
        } 
      
        //컴파일 후 
        public class MyComparator implements Comparator {
            public int compare(Integer a, Integer b) {
                //...
            }
      
            //bridge method
            public int compare(Integer a, Integer b) {
                return compare((Integer)a, (Integer)b);
            }
        }
        ```

- Typesafe Heterogeneous container pattern
  - 제네릭을 사용해서 유연한 자료구조를 만들 수 있다. 