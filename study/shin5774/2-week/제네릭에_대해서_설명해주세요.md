# 제네릭에 대해 설명해주세요.

## 답변

```
클래스 내부에서 사용할 객체의 데이터 타입을 외부에서 지정해주는 기법입니다. 이를 통해 기존의 Object 타입을 활용한 형변환보다 효율적으로 작업을 처리할수 있게 되었습니다.
```

### 예상 꼬리 질문 및 답변

- 효율적인 처리기반이라는게 정확히 어떤것을 의미하는가?
    - 답
    기존의 Object 타입을 이용한 형변환하는 과정에서는 개발자가 직접 형변환을 해줘야 했고 그러다보니 잘못된 형변환으로 인한 `런타임 에러`가 발생할 가능성이 있었습니다. 이를 제네릭을 사용하게되면 컴파일 시기에 에러를 파악하여 `컴파일 에러`가 발생해 쉽게 문제를 찾을수 있게되었습니다.
    - 런타임 에러와 컴파일 에러의 차이점이 무엇인가?
        - 답
        컴파일 타임 에러는 컴파일 시기에 발생하는 에러로 구문오류로 인한 프로그램 에러 입니다. 런타임 에러는 실제 런타임, 즉 프로그램이 실행되는 시기에 발생하는 에러로 개발자가 직접 원인을 추적해서 파악해야합니다.



- 제네릭을 사용함으로서 얻을수 있는 장점은 무엇이 있는가?
    - 답
    제네릭의 장점에는 두가지가 있다고 생각합니다. 첫번째로는 컴파일 타임에서 타입 검사를 통한 예외를 방지해주는 점이 있고 두번째로는 불필요한 `캐스팅` 비용을 없애줍니다. 기존 Obejct 타입을 이용한 형변환,즉 `다운캐스팅`의 과정에서 불필요한 성능을 잡아먹었는데 제네릭은 타입을 미리 지정하고 제한하였기에 타입 검사 및 변환에 관한 메모리도 줄일수 있게됩니다.
    - 캐스팅에 관해 설명해 보시오.
        - 답
        캐스팅이라는것은 하나의 데이터타입이 다른 데이터 타입으로 바뀌는것, 즉 형변환입니다. 캐스팅에는 크게 업캐스팅과 다운캐스팅으로 나뉩니다.
        업캐스팅의 경우는 자식클래스가 부모클래스로 형변환하는것을 의미합니다. 따라서 부모 클래스의 부분만 사용이 가능합니다. 하지만 자식 클래스에서 오버라이드 된 메서드의 경우는 자식클래스의 메서드를 사용하게됩니다.
        다운 캐스팅은 반대로 부모클래스가 자식클래스로 변환되는것을 의미하는데 정확히는 앞서 업캐스팅이 된 객체를 다시 자식클래스 타입으로 되돌리는것을 의미합니다.  즉 본래 객체가 가진 기능을 회복하기 위해 원상복귀 시키는것을 뜻합니다. 따라서 업캐스팅이 안된 객체를 다운캐스팅 하려고 하면 예외가 발생합니다.


- 제네릭의 단점은 무엇이 있는가?
    - 답
    타입을 사용자가 지정한다는 점에서 너무 자유롭다는 문제가 있습니다. 제네릭의 경우는 아무런 클래스가 다 들어가기 때문에 이로 인한 문제가 발생할수 있습니다. 이를 해결하기 위해 나온 개념이 extends,implements를 통한 클래스 제한을 거는것입니다.
    또한 제네릭의 타입간의 형변환이 불가하다는 점도 단점중 하나입니다.
    이를 보완하기 위해 `제네릭 와일드카드`라는 개념을 사용하지만 이 또한 개발자의 잘못된 설계로 인한 `힙 오염`의 위험성이라는 단점이 존재합니다.
    - 제네릭 와일드 카드란 무엇인가?
        - 답
        제네릭 타입간의 캐스팅을 가능하게 만들어주는 것입니다. 종류로는 크게 비경계, 상한제한,하한 제한 와일드 카드가 존재하며 비 경계를 제외한 나머지는 각각 받을수 있는 클래스에 대해 제한을 걸어주는 특징을 가집니다.
    - 힙 오염이란 무엇인가?
        - 답
        JVM의 힙 메모리영역에 저장된 변수가 불량 데이터를 참조하면서 런타임에러를 일으킬수 있는 오염상태를 의미합니다.



## 내용 정리

- 제네릭(Generic): 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법.

    간단하게 클래스 내부에서 사용할 객체의 타입을 지정해주는 것. 즉, 타입을 변수화 시킨 기능.

    - 장점
        1. 컴파일 타임에서의 타입 검사를 통한 예외 방지

            제네릭이 들어오기 전에는 자바에서는 여러 타입을 다루기 위해 Object 타입을 사용하였다. 하지만 이는 여러모로 **불편한 점**이 있었다.

            1. 차후에 일일이 타입변환을 해줘야함.
            2. 런타임 에러가 발생할 가능성
                - 잘못된 타입으로 변환되어서 예상외의 에러(런타임 에러)가 발생하지 않도록 컴파일 타입에 에러를 파악해줌.
                - 컴파일타임 에러와 런타임 에러의 차이
                    - 컴파일 타임에러

                        컴파일시 발생하는 에러로 구문오류(문법상의 문제)로 인해 프로그램이 컴파일 될수 없어서 발생하는 에러. 에러의 발생부를 알려준다.

                    - 런타임 에러

                        프로그램 실행시 발생하는 에러로 대부분 개발자의 설계 미숙으로 프로그램이 원치 않은 방향으로 돌아가서 발생한다. 에러 발생시 개발자가 추적해서 원인을 파악해야 한다.


        2.  불필요한 캐스팅을 없애서 성능을 향상

        Object형에서 다른 타입으로 형변환(다운캐스팅)을 하는데에 불필요한 성능을 잡아먹는다.

        하지만 제네릭은 타입을 미리 지정 및 제한을 시키기에 형 변환의 문제를 줄이며 타입 검사의 메모리도 줄이고 가독성도 좋아진다.

        - 캐스팅(형변환,Casting): 하나의 데이터 타입에서 다른 타입으로 바꾸는 것.
            - 업캐스팅/다운캐스팅: 부모 클래스와 자식클래스간의 형변환
                - 업캐스팅: 자식클래스가 부모 클래스로 형변환 되는것
                    - 특징
                        1. 부모 클래스의 구현된 것 만 사용가능
                        2. 오버라이드 된 메서드의 경우는 자식 클래스것으로 사용이됨.
                            - 오버라이딩의 특성상 런타임 환경에서 동적으로 바인딩 되기 때문
                    - 사용이휴유: 공통 부분을 만들어 간단하게 다루기 위해
                - 다운캐스팅: 부모클래스가 자식클래스로 형변환 되는것. , 정확히는 **업캐스팅 된 자식 클래스의 기능을 회복하기 위해** 다시 원상복귀 시키는것
                    - 업캐스팅이 안된 원래의 부모객체를 다운캐스팅 하면 오류가 발생함(ClassCastException)
                        - 이는 런타임 에러이기에 사용해 각별히 주의해야함.
            - instanceof 연산자: 해당 연산자를 통해 업캐스팅 다운캐스팅 가능여부를 알수 있음
                - Primitive 타입에는 사용할수 없음.

    - 단점
        - 자유로움: 아무 클래스나 다 들어갈수 있기에 잘못된 클래스를 넣어서 에러가 발생할 우려가 있음.
            - 해결책 : Extends,implements 키워드를 통해 제네릭에 제한을 걸수 있다.
                - Extends (클래스)
                    - EX) `<T extends Number>` → Number 클래스와 하위 타입만 받도록 제한.
                - implements (인터페이스)
                    - EX) 위와 동일, 다중 상속의 경우 & 로 표시. 이때는 두 인터페이스를 전부 구현한 클래스만으로 제한을 검.
                - 재귀적 타입 한정?
    - 문제점
        - 제네릭 캐스팅: 제네릭 서브타입간 형변환이 불가능함.
            - 해결책: 제네릭 와일드 카드(`?`)를 사용함
                - 변성(Variance): 타입의 상속 계층 관계에서 서로 다른 타입간의 관계를 나타내는 지표
                    - 공변성(Covariance): 서로 다른 타입간 함께 변할수 있다는 특지.
                    - 반공변성(Contravariance): 공변성의 반대개념
                    - 예시 (배열과 리스트)
                        - S 가 T 의 하위 타입인경우
                            - 공변
                                - S[]는 T[]의 하위 타입.
                                - List`<S>`는 List`<T>`의 하위 타입.
                            - 반공변
                                - T[]는 S[]의 하위 타입.
                                - List`<T>`는 List`<S>`의 하위 타입.
                - 제네릭은 공변성/반공변성을 지원하지 않는다.

                    간단하게 다운캐스팅,업캐스팅을 지원하지 않음. → 무공변의 성질을 지님.

                    이로서 발생하는 불편함을 해결하기 위해 제네릭 와일드 카드를 사용.

                - 와일드 카드의 종류
                    1. `<?>(비경계)`: 제한없이 사용가능
                    2. `<? extends T>(상한제한)`: T 또는 T의 자손 타입만 사용가능.
                    3. `<? super T>(하한제한)`: T와 T의 조상타입만 사용가능.
                    - extends와 super의 적절한 사용시기
                        1. PECS(Producer-Extends/ Consumer-Super)

                            생산시에는 extends를 소비시에는 Super를 사용

                        2. in-out

                            매개변수의 데이터를 가져오는(in) 용도에서는 extends를 사용

                            매개변수에 데이터를 적재하는(out)의 용도에서는 super를 사용

                - 주의 사항
                    1. 와일드 카드는 설계가 아닌 사용을 위한것이다.

                        제네릭 와일드카드는 클래스나 인터페이스에는 사용할수 없다.

        - 힙 오염의 위험성

            이전 자바버전과의 호환성을 위해 컴파일시 제네릭타입은 사라짐. 즉, 클래스 파일에는 제네릭 타입 정보가 없음.

            따라서 개발자가 제네릭을 잘못 설계하면 잠재적인 `힙 오염(heap pollution)` 문제에 빠질수 있음.

            - 힙 오염(heap pollusion): JVM의 힙 메모리영역에 저장된 변수가 불량 데이터를 참조하면서 런타임에러를 일으킬수 있는 오염상태
                - 해결책 (by list)

                    Collections의 checkedList() 메서드를 통해 의도치 않은 값의 삽입의 예외처리를 일으켜 힙 오염을 방지함.

            - 제네릭의 컴파일 과정.
                - Reifiable, Non-Reifiable
                    - Reifiable Type(실체화 타입): 컴파일 단계에서 타입소거에 의해 지워지지 않는 타입 정보.
                        - primitive type,일반 클래스와 인터페이스 타입, Raw type(List,Map…), List`<?>`,ArrayList`<?>`등 비한정 와일드카드가 포함된 매개변수화 타입.
                    - Non-Reifiable type(비실체화 타입): 컴파일 단계에서 타입소거가 되는 타입. 제네릭 타입은 모두 제거됨.
                - 소거 과정: 컴파일러가 소스 파일을 체크하면서 형변환후 컴파일코드에 Type Erasure로 제네릭 타입 제거
                    1. 제네릭 타입의 bound 제거.

                        제네릭 타입의 상한과 하한을 클래스로 변환. 및 `<T>`를 Object로 변환시켜줌.

                    2. 변환후 타입이 일치하지 않는곳을 형변환 시켜줌.
                - Bridge 메서드: 제네릭 타입의 타입소거에 대해 다형성을 보존하기 위해 생성하는 메서드
                    - 나온 이유
                        - 제네릭 타입이 소거되면서 기존의 의도와 다른 방식으로 작동 될수 있게됨 (오버라이딩→ 오버로딩으로 바뀜)

                            이러한 문제점을 막기위해 컴파일러가 런타임시 해당 제네릭 타입의 타입소거를 위한 Bridge 메서드를 생성해줌.

                    - 형변환을 통해 기존의 의도한 메서드로 연결되도록 함.
