# SOLID(객체지향 5대원칙)에 대해서 설명해주세요.

## 답변

```
SOLID는 객체지향을 지키기 위한 원칙들의 앞글자를 따서 만든 용어입니다.
각각 단일책임 원칙,개발 폐쇄 원칙,리스코프 치환 원칙,인터페이스 분리 원칙,의존관계 역전 법칙이 있습니다.
이러한 법칙들은 객체지향의 특징들을 지키도록 유도해주고 결과적으로 더욱 객체지향적인 코드를 짜게 됩니다.
```

## 내용 정리

- SOLID

  객체지향을 지키기 위한 원칙들의 앞글자를 따서 만든말

    - 원칙
        - 단일 책임 원칙(SRP,Single Responsibility Principle)

          `한 클래스는 하나의 책임만을 가져야 한다`

          변화에 의한 클래스 변경의 이유는 단 한가지여야 한다는 뜻이다.

            - 장점
                - 책임 영역이 확실해짐.

                  책임 변경으로 인한 변경의 연쇄작용에서 자유로워짐.

                - 가독성 향상 및 유지보수 용이
            - 적용 방법
                - 여러 원인으로 인한 변경(Divergent Change)

                  Extract Class를 통해 혼재된 각 책임을 각 클래스로 분할시켜 클래스당 하나의 책임을 맡도록 함. 이로 인해 분리된 클래스간의 관계의복잡도를 줄이도록 설계함.

                  만약 Extract Class인 각각의 클래스가 유사하고 비슷한 책임을 가지고 있다면 Extract superclass를 사용할 수 있음.

                - 산탄총 수술(Shotgun surgery)

                  Move Field,Move method를 통해서 책임을 기존 클래스로 옮기거나, 옮길만한 클래스가 없다면 새로운 클래스를 만들어내는 방식.

                  마치산탄총처럼 책임을 분배하는것 처럼 보임. 이를 통해 비슷한 책임을 한곳에 모음으로서 응집성이 향상이 된다.

                    - Move Field,Move method

                      메소드가 자신이 정의된 클래스보다 다른 클래스의 기능을 더 많이 사용하고 있다면 그 메서드를 많이 사용하고 있는 클래스에 옮긴 새로운 메서드를 만드는 기법.

            - 적용 시 유의점
                - 클래스는 이름에 맞는 일을 해야한다.
                - 클래스는 하나의 개념을 나타내야 한다.
                - 미 사용 속성은 분리의 결정적 증거이다.
                - 무작정 책임을 분리하는것이 SRP는 아니다.
        - 개방 폐쇄 원칙(OCP,Open Close Principle)

          소프트웨어 구성요소(Component,Class,Module,Function)은 확장에는 열려있고 변경에는 닫혀있어야 한다는 원칙으로, 수정을 줄임으로서 재사용성을 높여야 한다는 의미를 내포한다. 이때 추상화와 다형성이 해당 원칙을 가능케하는 중요 매커니즘이라 볼수 있다.

            - 적용 방법
                - 변경(확장)점과 불변점을 엄격하게 구분한다.
                - 두 모듈의 접점에 인터페이스를 정의한다.
                - 구현에 의존하기보다는 인터페이스에 의존하도록 코드를 작성한다.
            - 적용 시 유의점
                - 모듈을 분리하는 과정에서 크기의 조절실패시 관계가 오히려 복잡해 질수 있다.
                - 인터페이스는 가능하면 변경이 되어서는 안된다.
                - 인터페이스를 설계하는 과정에서 적당한 추상화 레벨을 선택해야한다.
        - 리스코프 치환 원칙(LSP,Liskov Substitution Principle)

          객체는 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀수 있어야 한다는 원칙으로 서브타입은 기반타입이 약속한 규약을 지켜야 한다는 뜻이다.

          즉 다형성과 확장성을 극대화 하기위한 원칙이라 볼수 있는데 이를 위해서 인터페이스를 사용하는것이 좋다. 만약 구체 클래스의 노출이 꺼려진다면 Abstarct Factory 등의 패턴을 사용한다. 상속은 두 클래스의 관계가 IS-A 관계일때만 사용을 하고, 이외는 합성(Composition)을 이용하여 재사용을 해야한다.

          상속과 다형성은 서로 땔수 없는 요소이기에 LSP는 OCP를 구성하는 구조가 된다.

            - Abstract Factory

              연관성이 있는 객체군들을 묶어서 추상화하고, 구체적 상황이 주어진경우 팩토리 객체에서 객체군을 구현화 하는 생성 패턴.

            - Composition(합성)

              클래스를 구성하는 부분의 합으로 정의하는것. 클래스의 필드로 다른 클래스가 있는 경우가 그 예시라고 볼수 있다.

            - 적용 방법
                - 두 개체가 동일한 일을 한다면 하나의 클래스로 표현하면서 이들을 구분할수 있도록 필드를 만든다.
                - 동일연산을 제공하지만, 과정이 조금씩 다르다면 공통의 인터페이스를 만들고 이를 구현한다. (인터페이스를 이용한 상속)
                - 공통된 연산이 없으면 별개의 클래스를 만든다.
                - 두 개체가 하는 일에 추가적인 일이 더 있다면 구현 상속을 사용한다.
            - 적용 사례
                - 컬렉션 프레임워크(Collection Framework)

                  컬렉션 프레임워크는 상단부의 인터페이스로 Collection이 존재하는데 이를 타입으로 사용해서 하위 클래스의 교체를 유연성 있게 할수 있다.

            - 적용 시 유의점
                - 혼동될 여지가 없고 트레이드 오프를 고려하여 선택된 것이라면 그대로 둔다.
                - 다형성을 위한 상속관계가 필요없는 경우에는 Replace with Delegation을 한다. LSP를 지키기 어려운 경우에는 상속 대신의 합성을 사용하는것도 좋은 방법이다.
                    - Delegation(위임)

                      다른 인스턴스의 메서드를 처리해서 호출하는것.

                    - Replace inheritance with delegation

                      상속을 위임으로 치환하는 과정으로 서브클래스가 슈퍼클래스 인터페이스의 일부만 사용하거나 상속 데이터를 사용하지 않는 경우, 슈퍼클래스를 위한 필드를 생성하고 슈퍼클래스를 대체하기 위한 메서드를 적용함으로 서브클래스화를 제거하는 것을 의미함.

                - 상속 구조가 필요한 경우에는 Extract Subclass,PushDown Field,Push Down Method등의 리팩토링 기법을 사용해 LSP를 준수하는 상속계층 구조를 구성한다.
                    - Extract subclass

                      클래스에 특정 인스턴스에서만 사용하는 기능들이 있다면 해당 기능들로 이루어진 서브클래스를 만드는 리팩토링 기버

                    - Field Push Down method

                      슈퍼클래스의 기능이 특정 서브클래스와만 연고나 있다면 해당 메서드를 그 서브클래스로 옮기는 기법.

                - IS-A 관계가 성립하여도 프로그램까지 그런건 아니다. 관계맺음은 역할,공유연산,연산의 차이점 등을 종합적으로 검토하여 결정해야한다.
                - Design by Contract를 적용한다.
                    - Designed by Contract(계약에 의한 설계)

                      메서드가 입력조건의 맞는 결과를 보장하도록 계약을 부과하는 설계로직으로 계약에는 사전조건,사후조건,사후 조건 안의 패널티,불변조건이 있다.

                        - 사전 조건

                          메서드 호출자가 지켜야 하는 조건으로 메서드는 호출자가 잘못된 값을 넣었을 경우에 대한 방어코드를 작성해야 한다.

                        - 사후 조건

                          메서드의 실행결과,리턴값, 메서드에 관련된 객체의 상태변화를 기술한 조건이다. 내부의 로직이 정상적으로 동작해는지에 대한 결과를 체크하는 조건이다.

                        - 사후 조건 안의 패널티

                          잘못된 사전조건을 입력했을 경우에 대한 방어코드로 사용자 입력에 대한 예외처리라고 볼수 있다.

                        - 불변 조건

                          클래스필드에 대해 항상 참인 조건으로 어떠한 메서드를 수행하더라도 항상 참인 조건을 의미한다.

                        - 계약 검사

                          계약에 대한 검사를 하는 과정으로 방법은 3가지가 있다.

                            - 방법
                                - 구현 메서드에 if문을 두어서 검사한다.
                                - 구현 메서드에 assert키워드를 사용한다.(1.4버전 이상)
                                - 테스트 프레임워크를 사용한다.
        - 인터페이스 분리 원칙(ISP,Interface Segregation Principle)

          하나의 범용 인터페이스보다는 여러개의 구체적 인터페이스가 더 좋다는 원칙이다. 즉 한 클래스가 다른 클래스에 종속이 될때는 가능한 최소의 인터페이스만을 이용해야 한다는것을 내포한다.

            - 적용 방법
                - 클래스 인터페이스를 통한 분리

                  클래스 상속을 통해 인터페이스를 분리한다.

                - 객체 인터페이스를 통한 분리

                  위임(Delegation)을 이용해 인터페이스를 분리한다.

                    - 위임

                      특정 일의 책임을 다른 클래스나 멧드에 맡기는 것을 의미한다. 타 클래스의 기능을 변경없이 사용하려면, 상속 대신 위임을 사용한다.

            - 적용 사례
                - Java Swing의 JTable

                  JTable 클래스에는 상당수의 메서드가 있고 이로 인해 여러 역할이 하나의 클래스에 혼재되어 있다. 하지만 이를 ISP가 제안한 방식으로 모든 인터페이스 분리를 통해 특정 역할만을 이용하도록 했다.

            - 적용 시 유의점
                - 이미 구현된 클라이언트에는 변경을 주면 안된다.
                - 두가지 이상의 인터페이스가 공유하는 부분의 재사용을 극대화 하도록 한다.
                - 서로 다른 성격의 인터페이스를 명확하게 분리한다.
        - 의존관계 역전 원칙(DIP,Dependency Inversion Principle)
            - Dependency Inversion(DI,의존관계 역전)

              구조적 디자인에서 발생하던 하위 레벨의 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 것으로 위계관계를 끊는 의미의 역전이다.

            DI를 통해 실제 사용관계는 바뀌지 않지만 추상을 매개로 메시지를 주고 받으면서 관계를 최대한 느슨하게 만드는 원칙으로 복잡한 컴포넌트간의 커뮤니케이션 관계를 단순화하는데에 의도가 있다.
            
            - 키워드
                - IOC
                - 훅 메서드
                - 확장성
            - 적용 방법
                - Layering
                    
                    상위 레벨의 레이어가 하위레벨의 레이어를 직접적으로 의존하는것이 아닌, 둘 사이에 추상레벨을 두어서 이를 통해 의존하는 방식이다. 이를 통해 상위레벨의 모듈은 하위레벨의 모듈로의 의존성에서 벗어나게 되어 재사용성과 확장성도 보장 받을수 있게 됩니다.
                    
            - 적용 사례
                - 통신 프로그래밍 모델
                - 이벤트 드리븐,콜백 JMS 모델