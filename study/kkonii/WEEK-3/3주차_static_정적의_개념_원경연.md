## 정적(static)이란 무엇인가요?

---

### - 스태틱 변수와 인스턴스 변수의 차이?
스태틱(static) 변수는 클래스(Class) 레벨에서 선언되며, `static` 키워드를 사용해서 정의된다.    
클래스의 모든 인스턴스는 스태틱 변수를 공유한다. 
즉, 한 클래스의 모든 객체가 동일한 스태틱 변수의 값을 공유하고, 이 값은 클래스가 메모리에 로드될 때 생성되어 프로그램 종료시까지 유지된다.   
스태틱 변수는 클래스 이름을 통해 직접 접근할 수 있기 때문에, 객체 생성이 필요하지 않다.

반면, 인스턴스(instance) 변수는 객체(Object) 레벨에서 선언되며, 각 객체는 자신만의 인스턴스 변수를 가지고 있다.    
이 변수들은 클래스의 각 인스턴스가 생성될 때마다 새롭게 할당되며, 각 객체는 해당 변수에 대해 고유한 값을 가진다.    
인스턴스 변수에 접근하기 위해서는 먼저 해당 클래스의 객체를 생성해야 한다. 


### - 정적 메소드와 인스턴스 메소드의 차이?
정적 메소드는 `static` 키워드를 사용하여 선언되며, 클래스의 인스턴스를 생성하지 않고도 호출할 수 있다.   
주로 유틸리티(utility) 함수에 사용되며 인스턴스 변수 혹은 메소드에 접근할 수 없다.
반면, 인스턴스 메소드는 객체 레벨에 선언되는 메소드로, 객체를 생성한 후에만 사용할 수 있다.

인스턴스 메소드에서는 정적인 요소에도 접근이 가능하지만, 정적 메소드에서는 정적 변수 혹은 메소드만 사용할 수 있다.


### - `static` 키워드를 사용할 때 주의해야 할 점?
1. **메모리 관리**
   - 정적 변수 혹은 메소드는 프로그램이 시작될 때 메모리에 할당되고 프로그램이 종료될 때까지 남아있는다.
   - static 키워드를 과하게 사용하면 메모리의 사용에 영향을 미칠 수 있다.

2. **객체 지향 원칙**
   - 정적 메소드는 인스턴스 변수 혹은 메서드에 접근할 수 없다.
   - 이는 객체 지향의 원칙인 `캡슐화`와 `상속`을 약화시킬 수 있으므로, 객체의 상태와 밀접한 연관이 있는 기능은 인스턴스 메소드로 구현하는 것이 적합하다.

3. **멀티 스레드 환경**
   - 정적 변수는 모든 인스턴스에 의해 공유되기 때문에, 멀티 스레드 환경에서 동시성 문제를 야기할 수 있다
   - 여러 스레드가 동시에 같은 static 변수에 접근하는 경우, 데이터의 일관성을 유지하기 위한 조치가 필요하다

4. **테스트의 어려움**
   - 정적 메소드 혹은 변수는 테스트가 어려울 수 있다
   - 특히, 단위 테스트를 수행할 때 static 요소에 의존하는 코드는 모의 객체(mock objects)를 사용한 테스트가 어렵다


### - 정적 메소드가 오버라이딩될 수 있는지, 그리고 그 이유는 무엇인지?
결론부터 말하면, 정적 메소드는 오버라이딩 될 수 없다. 정적 메소드는 클래스 레벨에서 정의되는, 즉 인스턴스가 아닌 클래스가 연결되어 있기 때문이다.    
`오버라이딩`은 인스턴스 메소드에서만 발생하며, 런타임에 결정된다. 반면 정적 메소드의 경우 어떤 메소드가 호출될지는 컴파일 타임에 결정된다.


### - 클래스 로더(Class Loader)가 정적 변수를 처리하는 과정?
1. **클래스 로딩**
   - 자바 프로그램이 실행되면, 클래스 로더는 필요한 클래스 파일(.class)을 찾아서 JVM 메모리에 로드

2. **정적 변수 초기화**
   - 클래스가 메모리에 로드되면, JVM은 그 클래스의 정적 변수를 초기화
   - 정적 변수는 프로그램 실행 중 한 번만 초기화되며, 그 이후에는 해당 클래스의 모든 인스턴스에 의해 공유

3. **정적 초기화 블록 실행**
    - `정적 초기화 블록`이 정의되어 있다면, 이 블록도 클래스가 로드 되고 정적 변수가 초기화된 직후 실행됨


### - 정적 변수가 프로그램의 메모리에 어떤 영향을 미치는지, 그리고 그 이유?
1. **메모리 할당**
   - 정적 변수는 클래스 당 한 번만 메모리에 할당되고, 클래스가 메모리에서 언로되 될 때까지 그 메모리 공간을 차지

2. **전역 접근**
   - 정적 변수는 해당 클래스의 모든 인스턴스에 의해 공유
   - 이는 하나의 클래스 인스턴스가 정적 변수의 값을 변경하면, 그 변경이 프로그램의 다른 모든 부분에서도 반영된다는 것을 의미
   - 정적 변수는 프로그램의 전역 상태를 유지하는 데 사용

3. **메모리 절약**
   - 각 객체 인스턴스에 대해 별도의 복사본을 생성하지 않기 때문에 메모리 사용을 절약 가능
   - 동일한 데이터를 저장하기 위해 추가적인 메모리 공간이 필요하지 않음

4. **메모리 누수 위험**
   - 정적 변수는 프로그램이 종료될 때까지 메모리에 남아 있기 때문에 메모리 누수(memory leak)의 위험이 있음

5. **스레드 안전성의 문제**
   - 멀티스레드 환경에서, 여러 스레드가 동시에 정적 변수에 접근하고 수정할 수 있기 때문에, 동시성 문제가 발생할 수 있음


### - 싱글톤(Singleton) 패턴에서 정적 변수를 사용하는 이유?
`싱글톤` : 인스턴스가 프로그램 내에서 단 하나만 존재하도록 보장하는 디자인 패턴

1. **단일 인스턴스 유지**
    - 싱글톤 패턴의 핵심은 클래스의 단일 인스턴스만을 생성하고 유지하는 것
    - 이를 위해, 클래스 내부에 정적 변수를 사용하여 유일한 인스턴스를 저장하고 모든 객체가 이를 공유

2. **글로벌 접근 지점 제공**
   - 싱글톤 인스턴스에 접근할 수 있는 글로벌 접근 지점을 제공하기 위해, 정적 메소드를 통해 어디서든 싱글톤 인스턴스에 접근
   - 이 메소드는 내부적으로 정적 변수에 저장된 인스턴스를 반환

3. **지연 초기화**
    - 때때로 싱글톤 인스턴스는 필요할 때까지 생성하지 않는 것이 바람직하다는 것
    - `getInstance()` 메소드 호출 시, 인스턴스가 아직 생성되지 않았다면 새로 생성하고, 이미 있다면 기존 인스턴스를 반환

4. **메모리 효율성**
   - 클래스의 인스턴스가 여러 번 생성되지 않도록 하여 메모리 사용을 최적화
   -  동일한 자원에 대한 중복 할당을 방지


### - 정적 메소드를 사용하는 경우
1. **유틸리티 함수**
   - 특정 인스턴스에 종속되지 않고, 일반적인 기능을 제공하는 경우
   - 객체의 상태에 영향을 받지 않고, 입력된 매개변수만을 사용하여 결과를 반환하는 경우

2. **싱글톤**
   - 인스턴스를 반환하는 getInstance() 메소드는 정적 메소드로 구현
   - 이 메소드는 클래스의 유일한 인스턴스를 반환하거나, 없을 경우 새로 생성

### - 정적 메소드를 사용하지 않는 경우
1. **객체 상태에 의존적인 메소드**
   - 예시 : ArrayList 클래스의 size( )와 같이, 객체의 인스턴스 변수 혹은 상태에 의존하는 경우

2. **상속과 다형성**
   - 메소드가 하위 클래스에서 오버라이딩되어 다른 행동을 해야 하는 경우 

3. **인터페이스 구현**
   - 인터페이스에 선언된 메소드들은 인스턴스 메소드로 구현되어야 함 
   - 인터페이스를 구현하는 클래스는 해당 메소드들을 반드시 오버라이드 해야하기 때문