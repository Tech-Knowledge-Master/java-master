## Java 8에서 추가된 기능에 대해서 설명해주세요.

---

### 1. 람다 (Lambda Expression)
함수를 하나의 `식`으로 표현한 것. 람다식 표기를 사용하면 메소드의 이름이 필요 없기 때문에, 익명 함수(Anonymous Function)라고 할 수 있다.
람다식은 주로 함수형 인터페이스(functional interface)의 인스턴스를 생성할 때 사용되며, 괄호() 와 화살표-> 를 이용해 함수를 선언한다.

```
(매개변수 목록) -> { 표현식 또는 문장들 }
```

#### 1-1. 왜 사용하는가
1. 코드의 간결성
   - 함수를 한 줄의 코드로 간결하게 작성할 수 있다. 이는 코드의 가독성을 향상시킨다.

2. 익명성
   - 이름이 필요없기 때문에, 일시적으로 사용되는 작은 함수를 정의할 때(특히 이벤트 핸들러나 콜백 함수를 작성) 유용하다.

3. 편리한 데이터 처리
   - 리스트 컴프리헨션(list comprehension)과 함께 사용되거나, 맵(map), 필터(filter), 리듀스(reduce) 같은 고차 함수와 결합되어 데이터를 효율적으로 처리할 수 있다.


### 2. Optional<T>
`java.util` 패키지에 포함되어 있는 제네릭 클래스로, 주로 값이 있거나 없을 수 있는 객체를 감싸는 데 사용된다.   
Optional 의 주요 기능은 다음과 같다.

- null 참조를 직접적으로 다루는 대신에, 값이 있거나 없음을 `명시적으로` 표현한다
- 메소드가 null을 반환할 수 있는 경우, Optional<T>를 반환함으로써 API 사용자에게 명확하게 그 가능성을 알릴 수 있다
- `map`, `flatMap`, `filter` 등의 메소드를 제공하여 함수형 프로그래밍 스타일을 지원한다

#### 2-1. 어떤 점을 보완하기 위해 새로 생겼는가
1. 개선된 `Null 처리` : 값이 없는 상황을 처리하는 전통적인 방식을 개선
   - null 값의 사용은 코드의 명확성을 해치고, NullPointerException 같은 런타임 오류의 주요 원인이 된다
   - 값이 존재할 수도, 존재하지 않을 수도 있는 상황을 보다 명시적으로 다룸으로써 `null 체크`를 체계적으로 관리하고, 예외 사항을 줄일 수 있다

2. 함수형 프로그래밍 지원 강화
   - Java 8은 함수형 프로그래밍 패러다임을 강화하기 위한 여러 기능을 도입 (lambda, stream API)
   - Optional 은 이러한 함수형 프로그래밍 접근 방식과 잘 어울린다


### 3. 스트림 API
필터링, 변환 등 다양한 방식으로 배열이나 컬렉션 (List, Map 등) 을 반복적으로 처리하는 도구    
컬렉션을 람다식으로 처리하여 복잡하고 방대한 데이터들을 간결한 코드만으로 처리할 수 있다.

#### 3-1. 스트림은 어떤 점에서 용이한가
1. 코드의 가독성
   - 컬렉션을 처리하기 위해 복잡한 조건문, 반복문을 사용하는 Java8 이전 버전까지의 복잡성 개선
   - 길고, 이해와 유지보수가 어렵던 코드를 간결하게 만든다

2. 병렬 처리 용이성
   - 병렬 처리는 대규모 데이터 세트를 다룰 때 성능 향상을 위해 필요하다.
   - 이전의 Java에서는 병렬 처리를 구현하기 어려웠지만, Stream API는 `.parallelStream()` 를 통해 병렬 처리를 쉽게 구현할 수 있도록 지원한다.

3. 추가적인 연산 지원
   - 데이터를 필터링, 변환, 정렬, 집계하는 등의 다양한 연산을 지원한다
   - 별도의 라이브러리나 복잡한 코드가 필요했던 이전 방식의 작업 복잡독 감소


### 4. 인터페이스 default 메서드
인터페이스에 있는 구현 메서드를 의미한다.
default 접근 제어자를 사용해 새로운 기능(메서드)을 인터페이스에 추가할 수 있다.

#### 4-1. 도입된 배경
기존의 인터페이스는 새로운 메소드를 추가할 경우, 해당 인터페이스를 구현한 모든 클래스들이 새로운 메소드를 구현해야 했다.
때문에 default 메서드는 인터페이스에 새로운 기능을 추가하면서 기존에 해당 인터페이스를 구현한 클래스들이 영향을 받지 않도록 하는 것을 목적으로 생겨났다.

#### 4-2. default 메서드의 사용으로 발생할 수 있는 문제가 있는가

- 여러 인터페이스에 정의되어 있는 `default 메서드 간의 충돌`
- default 메서드와 `상위 클래스 메서드와의 충돌`

이러한 충돌 문제가 발생할 경우, 충돌 상황이 일어나는 클래스에서 defalt method를 재정의하여 해결할 수 있다.
즉, 어떤 인터페이스의 메서드를 사용할지 명시적으로 결정해야 한다.


### 5. 메서드 참조 (Method Reference)
메서드의 참조를 전달한다는 의미로, 이것을 활용하면 람다 표현식에서 하나의 메소드만을 호출하는 경우 불필요한 매개변수를 제거하고 더 간단하게 코드를 줄여서 사용할 수 있다.

```
객체 또는 클래스명::메서드명
```

1. 정적 메서드 참조 (Static Method Reference)
   - `String::valueOf`
   - (str) -> String.valueOf(str)와 동일한 기능

2. 특정 객체의 인스턴스 메서드 참조 (Bound Instance Method Reference)
   - `System.out::println` 👉 System.out 객체의 `println` 메서드 참조와 같다

3. 특정 타임의 임의 객체의 인스턴스 메서드 참조 (Unbound Instance Method Reference)
   - `String::toLowerCase` 👉 String 타입의 임의 개체에 대한 toLowerCase 메서드를 참조
   - (x) -> x.toLowerCase()

4. 생성자 참조 (Constructor Reference)
   - `ArrayList::new`