## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

---

세 클래스는 모두 문자열을 저장하고, 관리하는 클래스이다. 각각의 차이를 살펴봅시다.

### 1. StringBuilder, StringBuffer 가 생겨난 이유
String 객체가 `불변(immutable)`이기 때문이다. String 객체는 한 번 생성되면 할당된 메모리 공간이 변하지 않는다.    
`+` 연산자를 통해 문자열을 합치는 것은 `가변(mutable)`으로 보일 수 있으나, 
이는 String 객체를 `새로` 생성한 후, + 연산자로 연결된 문자열을 저장하는 것이다.    
따라서 문자열 연산이 많은 경우에 String을 사용하면 `성능 저하`가 발생할 수 있다. 이러한 이유로 가변 객체인 `Builer`와 `Buffer`가 등장  


### 2. Builder, Buffer 의 공통 특성
Builder와 Buffer는 문자열의 연산(추가,수정,삭제)에 대해 `유연`하다는 특성이 있다.    
이들은 String 과는 다르게 문자열 연산 등으로 기존 객체의 공간이 부족하게 되는 경우, 새로운 객체 생성 없이 `기존의 버퍼 크기를 늘리며` 동작


### 3. String, Builder, Buffer 의 차이
1. **String**
    - 불변 객체
    - 멀티스레드 환경에서 안전하며, 공유될 때 동기화 문제 발생❌
    - 문자열의 수정이 적은 경우에 적합

2. **StringBuilder**
    - 가변 객체
    - 멀티스레드에서 안전하지 않음, thread-safe❌
      - 동기화로 인한 오버헤드가 없으므로 단일 스레드 환경에서 안전
    - 동기화 보장❌
    - thread-safe 여부가 전혀 관계 없는 프로그램을 개발할 경우 적합

3. **StringBuffer**
    - 가변 객체
    - 스레드 안전(thread-safe)
    - 내부적으로 메소드들이 `synchronized`로 구현하여 멀티스레드 환경에서도 동기화 지원
      - 여러 스레드가 동시에 접근하더라도 각 메소드 호출이 `순차적으로` 처리
    - 스레드에 안전한 프로그램이 필요할 때나, 개발 중인 시스템의 부분이 스레드에 안전한지 모를 경우 적합


### String, Builder, Buffer 사용시 주의
1. **String**  
- 1️⃣ 연산시 매번 새로운 객체 생성
   - `메모리` 사용이 증가하고, GC에 부담을 줌
   - 반복문 내에서 문자열을 변경하는 경우, `성능 저하`가 심각해질 수 있음

2. **StringBuilder**   
- 1️⃣ 멀티 스레드에서 불안전
   - 여러 스레드가 동시에 같은 StringBuilder 객체에 접근할 경우 `데이터 무결성`에 문제가 발생

- 2️⃣ 내부적으로 동기화 처리❌
   - 멀티스레드 환경에서 추가적으로 동기화 처리를 해야 함

3. **StringBuffer**
- 1️⃣ 단일 스레드 속도 저하
  - 모든 메소드는 `synchronized` 처리가 되어 있으므로, 단일 스레드 환경에서는 느릴 수 있음

- 2️⃣ 동기화 오버헤드(overhead)
  - 싱글 스레드 애플리케이션에서 사용할 경우, `불필요한 동기화 비용`으로 인해 비효율적일 수 있습니다.