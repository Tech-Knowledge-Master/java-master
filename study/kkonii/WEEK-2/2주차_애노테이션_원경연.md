## 애노테이션에 대해서 설명해주세요.

---

### 🎨의미
영어로는 `annotation`, `주석`을 의미    
프로그래밍에서는 코드가 특별한 의미를 가지고 기능을 수행하게 하는 메타 데이터

### 🎨특징
- JDK 1.5부터 사용이 가능
- 마치 주석과 같이 코드 실행에는 영향을 미치지 않음
- 작성시, 문자 `@`로 시작
- 클래스, 메서드, 인터페이스, 생성자, 변수, 매개변수 등에 사용
- `리플렉션(reflection)`과 같이 활용
- 문서, 컴파일러 혹은 IDE, 테스트 프레임워크(JUnit, JCStress 등)나 ORM(Hibernate, JPA 등) 등에서도 사용

        ⬜ 리플렉션이란?
        - 프로그램이 실행 중에 자신의 구조를 검사하고 조작할 수 있는 프로세스
        - 런타임시 클래스, 필드, 메소드, 애노테이션 등에 대한 정보 조회, 수정 가능


### 🎨어노테이션 종류

1. `@OVERRIDE`
   : 부모 클래스의 메서드를 오버라이딩하고 있는지 확인한다.    
   상속받거나 구현한 클래스 혹은 인터페이스에서 `메서드 시그니처`와 `반환형`이 일치하는 메서드를 찾지 못하면 `컴파일 에러` 발생

       ⬜ 메서드 시그니처란? 
       - 자바에서 프로그래머가 디자인한 메서드 구조를 의미
       - 메서드 이름과 파라미터 리스트로 구성

   왜 사용하는가? ▶ 개발자가 사소한 오타 혹은 올바른 오버라이딩 구현 여부를 빠르게 확인이 가능

2. `@DEPRECATED`
   : 중요도가 떨어져 더 이상 사용되지 않고 앞으로는 사라지게 될 `클래스`, `메서드`, `필드`에 사용
   이 경우. 컴파일러가 `경고` 혹은 `취소선`으로 표시

   사라지지 않고 남아있는 이유? ▶ 이전 버전과의 호환을 위해 존재   
   왜 사용하는가? ▶ 개발자가 더 안전하고 업그레이드 된 방법이 있음을 고지

3. `@SUPPRESSWARNINGS`
   : 컴파일러의 경고를 무시할 때 사용

   어떨 때 경고를 무시하나? ▶ 개발자가 어떠한 의도를 유지한 채 개발을 진행하려고 할 때   
   왜 사용하는가? ▶ 경고를 무시하지 않고 해결하는 것이 보통이지만,
   개발자가 `경고를 인지하고 있으며 이것이 내가 의도한 바`라는 것을 컴파일러에게 전하고 싶을 때 사용

4. `@RETENTION`
   : 어노테이션의 유지 기한을 설정한다

    1. `RETENTIONPOLICY.SOURCE`
        - 자바 소스코드에서만 기록되고, 컴파일 된 후에는 기록되지 않는다

    2. `RETENTIONPOLICY.CLASS`
        - 컴파일이 된 바이트코드(==.class_에 어노테이션을 기록, 런타임 시부터는 기록되지 않는다
        - JVM이 어노테이션을 제거

    3. `RETENTIONPOLICY.RUNTIME`
        - 컴파일, 런타임시 모두 기록된다
        - JVM이 어노테이션을 제거 X


### 🎨내장 애노테이션과 사용자정의 애노테이션의 차이

- 내장 애노테이션 (Built-in Annotations)
  : 자바가 기본적으로 내장하고 있는 어노테이션

- 사용자 정의 애노테이션 (Custom Annotations)
  : 사용자가 직접 정의하여 사용하는 애노테이션    
  어떻게 정의하는가? ▶ `@interface`를 클래스 앞에 붙여서 정의한다.


### 🎨어노테이션 프로세서(Annotation Processor)
컴파일 단계에서 어노테이션의 코드에 정의된 일렬의 프로세스를 동작하게 하는 것   
어노테이션의 소스 코드를 분석하고 처리한다

동작 순서? ▶
1. 자바 컴파일러가 컴파일을 수행
2. 실행되지 않은 어노테이션 프로세서 수행
3. 프로세서가 애노테이션이 붙은 요소에 대해 처리
4. 컴파일러가 모든 애노테이션 프로세서가 실행되었는지 확인 ▷ 아닐 경우 반복


### 🎨어노테이션과 주석의 차이
1. 공통
    - 주석이라는 의미를 가진다
    - 정보를 제공하는 역할을 한다

2. 차이
    1. 주석
        - 정보 제공의 대상 == `개발자`
        - 소스 코드에 대한 설명이 목적
        - 컴파일 과정에서 무시된다
        - 프로그램에 직접적 영향을 미치지 X (컴파일러가 주석을 무시하기 때문)
        - 실행 가능한 코드에 포함 X

    2. 어노테이션
        - 정보 제공의 대상 == `프로그램`
        - 프레임워크나 라이브러리가 코드를 해석하고 처리하는 지침 제공이 목적
        - 컴파일러에 의해 해석된다
        - 프로그램, 코드의 동작에 영향을 준다
        - 컴파일, 런타임 시 중요한 역할을 한다 (프로그램의 동작을 정의 / 변경하기 때문)


### 🎨메타 어노테이션?
- 어노테이션을 정의하고 기능을 명시하는 특별한 유형의 어노테이션
- 주로 애노테이션의 동작 방식을 지정하고, 애노테이션을 어떻게 적용할지 규정하는 데 사용
- 어노테이션 자체에 적용되어 그 특성에 대한 정보를 제공

왜 사용하는가? ▶ 서비스의 규모가 거대해지면 Bean이 많아지고, 관리의 용이성 측면에서 사용


### 🎨어노테이션을 이용한 리플렉션(Reflection) 실행 과정
1. 어노테이션을 정의 및 사용
    - 어노테이션을 정의하고, 이를 요소(클래스, 메소드, 필드 등)에 적용
2. 리플렉션을 통한 어노테이션 접근
    - 리플렉션 API를 이용하여 특정 요소에 접근
3. 어노테이션의 정보를 조회
    - 리플렉션을 사용해 해당 요소에 적용된 어노테이션을 조회
4. 어노테이션 기반 로직 수행
    - 조회한 정보를 바탕으로 필요한 로직을 수행

이점? ▶ 코드의 유연성, 확장성에 용이 / 코드의 메타데이터를 동적으로 처리


### 🎨어노테이션 사용시 주의사항
1. 과도하게 사용하지 않고, 명확한 목적과 필요에 맞게 사용 (`가독성`의 측면)
2. 여러 프레임워크 또는 라이브러리 간에 호환되는 애노테이션을 사용하는 경우, 표준에 맞게 사용하는지 확인 (`유지보수성`의 측면)
3. 커스텀 애노테이션을 작성할 때는 가능한 모든 경우에 대해 충분히 테스트하고 검증 (`안전성`의 측면)