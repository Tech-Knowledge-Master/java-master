### 오버로딩과 오버라이딩의 차이를 알려주세요.

자바에서 다형성을 지원하는 방법으로
메소드 오버로딩과 오버라이딩이 있다.

- 오버로딩(Overloading)
: 같은 이름의 메서드 여러개를 가지면서,
매개변수의 유형과 개수가 다르게 하는 기술

- 오버라이딩(Overriding)
: 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용

---

### 메소드 시그니처(Method Signature)

- 두 메소드가 주어졌을 때
메소드 이름, 파라미터의 수, 파라미터 타입의 순서가 같으
메소드 시그니처가 동일하다 한다.
이 두 메소드는, 같은 메소드로 취급되어 두 개 이상 존재할 수 없다.

cf. 반환형(Return Type)은 메서드 시그니처에 포함되지 않는다.

### 메소드 오버로딩
- 메소드의 이름은 같지만,
메소드의 시그니처가 다른 메소드가 한 클래스에 2개 이상 존재하게 하는 기술을 의미한다.

- 접근 제어자도 제약 없이 사용할 수 있다. 다만, 접근 제어자는 메소드 시그니처에 포함되지 않는다.

```java
public static void testMethod(String s){
System.out.println("hi");
}

private static void testMethod(){
    System.out.println("hihi");
}
```
와 같은 형식의 오버로딩이 가능하다.

- 메소드 이름이 같지만, 메소드 시그니처가 다르려면
파라미터의 수 또는 타입이 달라야 한다.

- 만약, 메소드 이름과 파라미터의 종류와 순서가 같은데,
반환값만 다르다 해도 그것은 오버로딩으로 인정되지 않는다.
즉, 메소드 이름은 같은데 메소드 시그니처가 다른 메소드가 오버로딩된 메소드인데
메소드 시그니처에는 반환값이 포함되지 않으므로, 이는 메소드 오버로딩을 결정짓는 요소가 되지 못한다.

- 사용하는 이유 : 같은 기능을 하는 메소드를 하나의 이름으로 묶어, 메소드 이름을 절약할 수 있다.

### 메소드 오버라이딩
- 상속 혹은 구현의 관계에서 하위 클래스가 상위 클래스의 메소드를 재정의 혹은 구현하는 것이다.
- 오버라이드는 다음과 같은 조건을 만족해야 한다.
  - 메소드 시그니처가 동일하다.
  - 반환형의 타입을 그대로 하거나, 혹은 하위 클래스로 정의한다.

- 사용하는 이유 : 하나의 코드로 여러 종류의 객체를 다룰 수 있어, 사용하는 객체의 구현이 변해도 해당 객체를 사용하는 클라이언트는 영향받지 않는다.
즉, 유지보수성이 좋아진다.

---

### 오버로딩과 오버라이딩 메소드의 결정 시점
- 오버로딩된 메소드는 컴파일 시에 어떤 메소드를 실행할지 결정한다.
- 오버라이딩된 메소드는 런타임 시에 어떤 메소드를 실행할지 결정한다.

---
### 오버라이딩과 가상 메소드 테이블 ( 동작원리 )

#### 가상 메소드
- 다형성의 원리가 적용될 수 있는 멤버 함수(메소드)로써
동적 바인딩으로 처리되는 메소드를 의미한다.
- 동적 바인딩 수행 시 가상 메소드 테이블을 참조하여 매핑한다.
- 정적 바인딩이 아닌, 동적 바인딩으로 처리되기 때문에
컴파일 시점에 정해지지 않은, 실제로 존재하지 않는, 임시로 존재하는 메소드라는 의미로 가상 메소드라 한다.

#### 가상 메소드 테이블

- 메소드의 이름은 주소값을 의미한다.
  ( JVM의 Method Area에서 해당 메소드가 저장되는 부분의 주소 )

- 메소드를 호출하게 되면, 해당 메소드의 바이트 코드가 실행된다.

- 자바에서는 모든 메소드가 가상 메소드로 취급된다.

- 클래스가 가상 메소드를 정의하고, 컴파일 시 컴파일러는 클래스에 숨겨진 멤머 변수를 추가한다.
이것은 (가상) 함수들에 대한 포인터들의 배열들( = 가상 메소드 테이블 : VMT )라고 한다.

- 이 포인터들은 실행 기간 도중 정확한 함수를 가리키게 된다.
왜냐면, 컴파일 타임에는 베이스 함수가 호출될지, 베이스 클래스를 상속한 클래스에 의해 구현될 지 알려지지 않기 때문이다.

- 특정 인스턴스의 메소드가 호출되면,
해당 클래스의 메타 정보가 들어있는 method 영역에 가서,
클래스의 가상 메서드 테이블을 확인한다.
이 때, 상속관계에 있는 자식 클래스의 VMT를 통해, 실제 Method Area의 동작 코드로 찾아간다.

예제 코드
```java
class Parent {
    void printMessage() {
        System.out.println("부모 클래스의 메시지");
    }
}

class Child extends Parent {
    @Override
    void printMessage() {
        System.out.println("자식 클래스의 메시지");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.printMessage();
    }
}
```

```text
Chat GPT와의 대화

Q.
obj,printMessage()
가 호출되면, 스택 영역의 메모리에 들어있는 obj 참조변수를 기반으로 Method Area의 함수 정의를 찾는거 아니야?
아니면, 스택 영역의 메모리에 있는 obj가 참조하는 힙 영역의 Child 객체를 기반으로 Method 영역의 VMT를 찾아가는거야?

A.

오버라이딩된 메서드 호출에 대한 동작을 설명하기 위해서는 스택과 힙 간의 상호작용을 이해해야 합니다.

메모리 할당: Parent obj = new Child();에서 obj는 스택 영역에 할당되며, new Child()로 생성된 실제 객체는 힙 영역에 할당됩니다.

메서드 호출: obj.printMessage();가 호출되면 스택 영역의 obj 참조 변수를 통해 실제 객체를 찾습니다. 여기서 obj의 타입은 Parent이지만, 객체의 실제 타입은 Child입니다.

VMT 활용: JVM은 실제 객체의 VMT를 찾습니다. VMT는 힙 영역에 해당 객체와 함께 생성되며, 오버라이딩된 메서드의 실제 주소를 포함합니다.

실제 메서드 호출: VMT에서 실제 오버라이딩된 메서드의 주소를 찾아내어 실행합니다. 이로써 자식 클래스의 메서드가 호출됩니다.

요약하면, 오버라이딩된 메서드 호출 시 JVM은 스택 영역의 참조 변수를 통해 힙 영역의 실제 객체를 찾고, 그 객체의 VMT를 통해 실제 메서드의 주소를 찾아내어 실행합니다. 이렇게 함으로써 동적 디스패치(Dynamic Dispatch)가 이루어져 오버라이딩된 메서드가 호출됩니다.
```

### JVM에서 Method Overriding을 어떻게 다루는가?